## Ch_02. 코틀린 기초

## 🔴 빨강

- p.59 스마트 캐스트는 타입 검사와 타입 캐스트, 타입 강제 변환을 하나로 엮은 기능이다.
- p.62 자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.
- p.63 본문이 중괄호로 둘러싸인 함수를 블록이 본문인 함수라 부르고, 등호와 식으로 이뤄진 함수를 식이 본문인 함수라고 부른다.
- p.64 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 타입추론이라 부른다. 식이 본문인 함수의 반환 타입만 생략 가능하다는 점에 유의하라.
- p.66 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경하라.
- p.67 이 문자열 템플릿은 자바의 문자열 접합 연산과 동일한 기능을 한다.
- p68. $ 문자를 문자열에 넣고 싶으면 println(”\%x”)와 같이 \를 사용해 $를 이스케이프 시켜야 한다.
- p.68 템플릿 안에서 변수 이름만 사용하는 경우라도 ${name}처럼 중괄호로 변수명을 감싸는 습관을 들이면 좋다.
- p.68 컴파일된 코드는 StringBuilder를 사용하고 문자열 상수와 변수의 값을 append로 문자열 빌더 뒤에 추가한다. 자바에서 + 연산으로 문자열과 변수를 붙여도 컴파일러는 StringBuilder를 사용하는 바이트코드를 생성한다.
- p.91 ..는 항상 범위의 끝값을 포함한다. 하지만 끝 값을 포함하지 않는 반만 닫힌 범위에 대해 이터레이션하면 편할 경우 until을 사용한다.
- p.97 자바 코드와 가장 큰 차이는 throws 절이 코드에 없다는 점이다. 자바에서는 함수를 작성할 때 함수 선언 뒤에 throws IOException을 붙여야 한다. 이유는 IOException이 체크 예외이기 때문이다. 자바에서는 체크 예외를 명시적으로 처리해야한다. (코틀린은 체크예외, 언체크예외의 구분이 없다.)

## 🔵 파랑

- p.64 아주 긴 함수의 리턴문이 여럿 들어있는 경우가 자주 있다. 그런 경우 반환 타입을 꼭 명시하고 리턴을 반드시 사용한다면 함수가 어떤 타입의 값을 반환하고 어디서 그런 값을 반환하는지 더 쉽게 알아볼 수 있다.
- p.66 val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다는 사실을 기억하라. (컬렉션 프레임워크)
- p.74 파라미터가 없는 함수를 정의하는 바잇ㄱ과 커스텀 게터를 정의하는 방식 중 어느 쪽이 더 나은지가 궁금한 독자도 있을 것이다. 두 방식 모두 비슷하다. 구현이나 성능상 차이는 없다. 차이가 나는 부분은 가독성 뿐이다.
- p.76 자바와 코틀린을 함께 사용하는 프로젝트에서는 자바의 방식을 따르는 게 중요하다.
- p.77 enum은 class 앞에 있을 때는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있다.
- p.82 when에 아무 인자도 없으려면 각 부닉의 조건이 불리언 결과를 계산하는 식이어야 한다.

## 🟢 초록
