## Ch_02. 코틀린 기초

## 🔴 빨강
- p.66 val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있음.
    
    ```kotlin
    // 불변 참조 선언
    val languages = arrayListOf("java")
    // 참조가 가르키는 객체 내부 변경
    languages.add("kotlin")
    ```
    
## **🔵 파랑**
- p.60 코틀린 문법, 특성
    - 함수 선언 시, fun 키워드 사용
    - 파라미터 이름 뒤에 그 파라미터의 타입 명시
    - 함수를 최상위 수준에 정의 가능. 자바와 달리 꼭 클래스 안에 함수를 넣을 필요 없음
    - 코틀린에는 자바와 달리 배열 처리를 위한 문법이 따로 존재 x (자바 : [ ], 코틀린 : listof)
    - 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 wrapper 제공. ex) println
    - 줄 끝에 세미콜론 필요 x
- p.62 코틀린 if는 값을 만들어내지 못하는 문장이 아니고 결과를 만드는 식(expression)
- p.62 문(statement)과 식(expression)의 구분
    - 식 : 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있음
    - 문 : 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재, 아무런 값을 만들어내지 않음
    - 자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식
    - 제어 구조를 다른 식으로 엮어낼 수 있으면 여러 일반적인 패턴을 아주 간결하게 표현 가능
    - 대입문은 자바에서는 식이었으나 코틀린에서는 문이 되어 자바와 달리 대입식과 비교식을 잘못 바꿔 써서 버그가 생기는 경우가 없음
- p.63-4 반환 타입 생략 가능 이유
    
    식이 본문인 함수의 경우 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해줌.
    
    - 타입 추론 : 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능
- p.66 기본적으로는 모든 변수를 val 키워드를 사용해 불변 변수로 사용하고 나중에 꼭 필요한 경우 var로 변경해야 함. 변경 불가능한 참조와 변결 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워짐
- p.67 문자열 템플릿 : 자바의 문자열 접합 연산과 동일한 기능을 하지만 좀 더 간결하며, 자바 문자열 집합 연산을 사용한 식과 마찬가지로 효율적. 문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 $를 추가

    → 주의할 점 : 변수명 바로 뒤에 한글을 붙여 사용하면 코틀린 컴파일러는 영문자와 한글을 한꺼번에 식별자로 인식해 unresolved reference 오류 발생
    
    → 해결 방안 : 변수명을 {}로 감싸기
    
- p.70 값 객체(value object) : 코드 없이 데이터만 저장하는 클래스
- p.71 클래스라는 개념의 목적은 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것
- p.77 코틀린에서 enum은 소프트 키워드. 키워드인 class 앞에 있을 때는 특별한 의미를 지니지만 다른 곳에서 이름(변수명)에 사용 가능
- p.79 when 도 값을 만들어내는 식
- p.80 코틀린에서 when은 분기 조건에 상수만이 아닌 임의의 객체 허용 → 모든 경우를 쉽게 열거할 수 있음
- p.82 인자 없는 when 사용 시 불필효한 객체 생성을 막을 수 있음 - 아무 인자도 없으려면 각 분기 조건이 불리언 결과를 계산하는 식
- p.85 스마트 캐스팅 : 어떤 변수가 원하는 타입인지 일단 is로 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 마치 처음부터 그 변수가 원하는 타입으로 선언된 것처럼 사용 가능. 실제로는 컴파일러가 캐스팅 수행
- p.86 스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음에 그 값이 바뀔 수 없는 경우에만 작동. 예를들어 프로퍼티에 사용한다면, 반드시 val이어야 하며 커스텀 접근자를 사용한 것이어도 안됨.
- p.88 if나 when 모든 분기에 블록을 사용할 수 있음 → 블록의 가장 마지막 문장이 블록의 전체 결과 → 로그를 추가하고 싶다면 각 분기를 블록으로 만들고 블록의 맨 마지막에 그 분기의 결과 값을 위치시키면 됨.
- p.90 코틀린에는 자바의 for 루프에 해당하는 요소 없음. 범위 사용. .. 연산자로 시작 값과 끝 값을 연결해 범위를 만든다.
- p.93 구조 분해 구문을 맵이 아닌 컬렉션에도 활용 가능
- p.96 발생한 예외를 함수 호출 단에서 처리하지 않으면 함수 호출 스택을 거슬러 올라가면서 예외를 처리하는 부분이 나올 때까지 예외를 다시 던짐(rethrow … 코루틴 공식 문서에 언급된 단어)
- p.96 자바와 달리 코틀린의 throw는 식이므로 다른 식에 포함될 수 있음
- p.97 함수가 던질 수 있는 예외를 명시할 필요가 없음.
- p.97 자바 코드와 가장 큰 차이는 throws 절이 코드에 없다는 점. 자바에서는 함수를 작성할 때, IOException이 체크 예외(checked exception)이므로  함수 선언 뒤에 throws IOException을 붙여야 함 - 자바는 체크 예외를 명시적으로 처리해야함. 어떤 함수가 던질 가능성이 있는 예외나 그 함수가 호출한 다른 함수에서 발생할 수 있는 예외를 모두 catch로 처리해야하며, 처리하지 않은 예외는 throws 절에 명시
- p.98 코틀린은 다른 최신 JVM 언어와 마찬가지로 체크 예외와 언체크 예외를 구별하지 않음 → 함수가 던지는 예외를 지정하지 않고 발생한 예외를 잡아내도 되고 잡아내도 되지 않아도 됨.

## **🟢 초록**
- p.60 코틀린에서 타입 선언을 생략해도 된다는 사실을 보고, 코틀린이 어떻게 변경 가능한 데이터보다 변경할 수 없는 불변 데이터 사용을 장려하는 지 배운다.
- p.63 본문이 중괄호로 둘러싸인 함수를 블록이 본문인 함수, 등호와 식으로 이뤄진 함수를 식이 본문인 함수 … 인텔리제이 아이디어는 이 두 방식의 함수를 변환하는 메뉴가 존재
- p.65 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석하여 초기화 식의 타입을 변수 타입으로 지정
- p.65 변수 선언 키워드
    - val : 변경 불가능한(immutable) 참조를 저장하는 변수. 일단 초기화하고 나면 재대입 불가능. 자바의 final 변수
    - var : 변경가능한(mutable) 참조. 값 변경 가능. 자바의 일반 변수
- p.66  var 키워드 사용 시, 변수의 값은 변경 가능하지만 변수의 타입은 고정
- p.69 중괄호로 둘러싼 식 안에서도 문자열 템플릿 사용 가능.
    
    ```kotlin
    "${if(s.length>2) "too short" else "normal string ${s}"}"
    ```
    
- p.70 자바-코틀린 변환기는 자바 코드를 같은 일을 하는 코틀린 코드로 자동으로 변환해줌.
- p.70 코틀린의 기본 가시성 : public
- p.71 자바에서는 필드와 접근자를 한데 묶어 프로퍼티(property)라고 부르며, 프로퍼티라는 개념을 활용하는 프레임 워크가 많음. 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며, 코틀린 프로퍼티는 자바의 필드와 접근자 메서드를 완전히 대신함 → val로 선언한 프로퍼티는 읽기 전용, var로 선언한 프로퍼티는 변경 가능
- p.72 게터와 세터의 이름을 정하는 규칙에 예외 존재
    
    이름이 is로 시작하는 프로퍼티의 게터에는 get이 붙지 않고 원래 이름 그대로 사용, 세터에는 is를 set으로 바꾼 이름을 사용
    
- p.76 코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있음. 디스크상의 어느 디렉터리에 소스코드 파일을 위치시키든 관계없음. 패키지 구조와 디렉토리 구조가 맍아 떨어질 필요 없음
    
    → 자바와 코틀린을 함께 사용하는 프로젝트에서는 자바의 방식을 따르는 것이 중요
    
- p.78 enum클래스 안에 프로퍼티와 메서드를 정의할 수 있음
- p.81 코틀린 표준 라이브러리에는 인자로 전달받은 여러 객체를 그 객체들을 포함하는 집합인 Set 객체로 만드는 setOf라는 함수 존재
- p.86 자바와 달리 3항 연산자 없음
- p.92 .. 연산자는 숫자 타입의 값뿐 아니라 문자 타입의 값에도 적용 가능
- p.93 get과 put을 사용하는 대신 map[key]나 map[key] = value를 사용하여 값을 가져오고 설정할 수 있음.
- p.94 in 연산자를 사용해 어떤 값이 범위에 속하는지 검사할 수 있음. 컬렉션에도 사용 가능
- p.99 if와 달리 try의 본문을 반드시 중괄호 {}로 둘러싸야함. 다른 문장과 마찬가지로 try의 본문도 내부에 여러 문장이 있으면 마지막 식의 값이 전체 결과 값

### 요약
- 함수 정의 - fun. 읽기 전용 변수 - val. 변경 가능 변수 - var
- 문자열 템플릿을 사용하면 문자열을 연결하지 않아도 되므로 코드가 간결헤짐. 변수 이름 앞에 $을 붙이거나, 식을 &{}로 둘러싸면 변수나 식의 값을 문자열 안에 넣을 수 있음
- 값 객체 클래스를 아주 간결하게 표현 가능
- if는 식이며 값을 만들어냄
- 코들린의 when은 자바의 switch와 비슷하지만 더 강력
- 어떤 변수의 타입을 검사하고 나면 굳이 그 변수를 캐스팅하지 않아도 검사한 타입의 변수처럼 사용 가능. 컴파일러가 스마트 캐스트를 활용해 자동으로 타입 변경
- for, while, do-while 루프는 자바가 제공하는 같은 키워드의 기능과 비슷
    
    for은 더 편리. (맵을 이터레이션하거나 이터레이션하면서 컬렌션의 원소와 인덱스를 함께 사용해야 하는 경우)
    
- 1..5 같은 식은 범위를 만들어냄. 범위와 수열은 코틀린에서 같은 문법을 사용/for루프에 대해 같은 추상화 제공. 어떤 값이 범위 안에 존재 유무를 in, !in 으로 검사.
- 코틀린 예외 처리는 자바와 비슷. 코틀린에서는 함수가 던질 수 있는 예외를 선언하지 않아도 됨.