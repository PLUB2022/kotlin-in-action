# 4장 종합

# Ch_04. 클래스, 객체, 인터페이스

## 상속한 인터페이스의 메서드 구현 호출하기

```kotlin
class Button : Clickable, Focusable {
    override fun click() = println("I was clicked")
    override fun showOff() = {
            super<Clickable>.showOff()
            super<Focusable>.showOff()
        }
}
```

- 이름과 시그니처 같은 멤버 메서드에 대해 둘 이상의 디폴트 구현이 있는 경우, 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야한다.
- 상위 타입의 이름을 꺽쇠 괄호(<>) 사이에 넣어 "super"를 지정하면 어떤 상위 타입의 멤버 메서드를 호출할지 지정할 수 있다.

## 클래스 내에서 상속 제어 변경자의 의미

| 변경자 | 이 변경자가 붙은 멤버는… | 설명 |
| --- | --- | --- |
| final | 오버라이드 할 수 없음 | 클래스 멤버의 기본 변경자다. |
| open | 오버라이드 할 수 있음 | 반드시 open을 명시해야 오버라이드할 수 있다. |
| abstract | 반드시 오버라이드해야 함 | 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현이 있으면 안 된다. |
| override | 상위 클래스나 상위 인스턴스의 멤버를 오버라이드하는 중 | 오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하려면 final을 명시해야 한다. |

## 내부 가시성 - 멀티 모듈

모듈 내부 가시성은 여러분의 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.

- 안드로이드 클린 아키텍처에서 사용

[[Android] 요즘 핫한 Clean Architecture 왜 쓰는 거야? : NHN Cloud Meetup](https://meetup.nhncloud.com/posts/345)

[멀티모듈 설계 이야기 with Spring, Gradle | 우아한형제들 기술블로그](https://techblog.woowahan.com/2637/)

## 가시성 변경자

- 자바에서는 같은 패키지 안에서 protected 멤버에 접근할 수 있지만, 코틀린에서는 그렇지 않다는 점에서 자바와 코틀린의 protected가 다르다는 사실에 유의하라
    
    → 클래스를 확장한 함수는 그 클래스의 private이나 protected 멤버에 접근할 수 없다는 사실! 
    
- internal 어디서 사용? 패키지 내부에서만 사용 가능하고, 외부 호출안되는 사례… 찾으면 수정
- 코틀린과 자바 가시성 규칙의 또 다른 차이는 코틀린에서는 외부 클래스가 내부 클래스나 중첩된 클래스의 private 멤버에 접근할 수 없다는 점이다.

## 자바와 코틀린의 중첩 클래스와 내부 클래스의 관계

| 클래스 B 안에 정의된 클래스 A | 자바에서는 | 코틀린에서는 |
| --- | --- | --- |
| 중첩 클래스 (바깥쪽 클래스에 대한 참조를 저장하지 않음) | static class A | class A |
| 내부 클래스 (바깥쪽 클래스에 대한 참조를 저장함) | class A | inner class A |

### sealed 클래스 - 맛있다!

- 자바 17에도 똑같이 상속 제한
- when 식에서 sealed 클래스의 모든 하위 클래스를 처리한다면 디폴트 분기가 필요 없음 → 서버는 예외를 던지는 것이 나을 수도