# 4장 종합

# Ch_04. 클래스, 객체, 인터페이스

## 상속한 인터페이스의 메서드 구현 호출하기

```kotlin
class Button : Clickable, Focusable {
    override fun click() = println("I was clicked")
    override fun showOff() = {
            super<Clickable>.showOff()
            super<Focusable>.showOff()
        }
}
```

- 이름과 시그니처 같은 멤버 메서드에 대해 둘 이상의 디폴트 구현이 있는 경우, 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야한다.
- 상위 타입의 이름을 꺽쇠 괄호(<>) 사이에 넣어 "super"를 지정하면 어떤 상위 타입의 멤버 메서드를 호출할지 지정할 수 있다.

## 클래스 내에서 상속 제어 변경자의 의미

| 변경자 | 이 변경자가 붙은 멤버는… | 설명 |
| --- | --- | --- |
| final | 오버라이드 할 수 없음 | 클래스 멤버의 기본 변경자다. |
| open | 오버라이드 할 수 있음 | 반드시 open을 명시해야 오버라이드할 수 있다. |
| abstract | 반드시 오버라이드해야 함 | 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현이 있으면 안 된다. |
| override | 상위 클래스나 상위 인스턴스의 멤버를 오버라이드하는 중 | 오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하려면 final을 명시해야 한다. |

## 내부 가시성 - 멀티 모듈

모듈 내부 가시성은 여러분의 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.

- 안드로이드 클린 아키텍처에서 사용

[[Android] 요즘 핫한 Clean Architecture 왜 쓰는 거야? : NHN Cloud Meetup](https://meetup.nhncloud.com/posts/345)

[멀티모듈 설계 이야기 with Spring, Gradle | 우아한형제들 기술블로그](https://techblog.woowahan.com/2637/)

## 가시성 변경자

- 자바에서는 같은 패키지 안에서 protected 멤버에 접근할 수 있지만, 코틀린에서는 그렇지 않다는 점에서 자바와 코틀린의 protected가 다르다는 사실에 유의하라
    
    → 클래스를 확장한 함수는 그 클래스의 private이나 protected 멤버에 접근할 수 없다는 사실! 
    
- internal 어디서 사용? 패키지 내부에서만 사용 가능하고, 외부 호출안되는 사례… 찾으면 수정
- 코틀린과 자바 가시성 규칙의 또 다른 차이는 코틀린에서는 외부 클래스가 내부 클래스나 중첩된 클래스의 private 멤버에 접근할 수 없다는 점이다.

## 자바와 코틀린의 중첩 클래스와 내부 클래스의 관계

| 클래스 B 안에 정의된 클래스 A | 자바에서는 | 코틀린에서는 |
| --- | --- | --- |
| 중첩 클래스 (바깥쪽 클래스에 대한 참조를 저장하지 않음) | static class A | class A |
| 내부 클래스 (바깥쪽 클래스에 대한 참조를 저장함) | class A | inner class A |

### sealed 클래스 - 맛있다!

- 자바 17에도 똑같이 상속 제한
- when 식에서 sealed 클래스의 모든 하위 클래스를 처리한다면 디폴트 분기가 필요 없음 → 서버는 예외를 던지는 것이 나을 수도

## Kotlin is

- 코틀린의 is 검사는 자바의 instanceof와 같다. is는 코틀린에서 자주 사용하는가?
  -> 현재 Plub에서 sealed 클래스로 적용된 Event 처리에서 가장 많이 사용한다. is는 타입 검사와 동시에 스마트캐스팅도 되기 때문에 매우 자주 사용

```kotlin
class AnyEvent { 
    fun run(
      //DO ANYTHING
    )
}

if(type is AnyEvent){
    type.run()
}
```
위 코드처럼 사용이 가능하다. 다만
```kotlin
type is AnyEvent
type.run()
```
과 같은 사용은 불가능하다 if를 통해 type이라는 변수가 AnyEvent라는걸 확인 가능하지만 2번째 코드에서는 type이 AnyEvent가 아닐 수 있기 때문에 스마트캐스팅이 안되면서 run 함수를 찾을 수 없다.

- ChatGPT
  -> 코틀린에서 스마트 캐스팅은 변수나 식의 타입을 검사하여 자동으로 타입 변환을 수행하는 기능입니다. 스마트 캐스팅은 다음과 같은 조건을 만족할 때 수행됩니다.
  1. 변수나 식의 타입이 'is' 연산자나 '!is' 연산자를 사용하여 검사되었을 때
  2. 변수나 식이 'if 문, when' 문 등 제어 흐름문의 블록 내에서 사용될 때
  3. 변수나 식이 'try-catch' 블록 내에서 사용될 때
  4. 변수나 식이 synchronized' 블록 내에서 사용될 때
     이러한 조건을 만족할 경우, 변수나 식의 타입을 검사한 이후에는 해당 타입으로 자동으로 캐스팅됩니다. 이를 통해 코드의 가독성을 높이고, 안전성을 확보할 수 있습니다.

## 해시 컨테이너 hashCode()

자바에서는 equals를 오버라이드 할 때 반드시 hashCode도 함께 오버라이드해야 한다.
JVM 언어에서는 equals()가 true를 반환하는 두 객체는 반드시 같은 hashCode()를 반환해야 한다는 제약이 있기 때문.
추가로 HashSet은 원소를 비교할 때 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 해시 코드가 같은 경우에만 실제 값을 비교한다.


## Data Class

스터디원 중 1명은 실제 면접에서 다음과 같은 질문을 받았다.
Data class와 class의 차이점은 무엇인가?
코틀린은 class 앞에 data라는 변경자를 앞에 붙이면 필요한 메서드를 컴파일러가 자동으로 만들어준다. 이를 data class라 부른다.
- 인스턴스 간 비교를 위한 equals
- HashMap과 같은 해시 기반 컨테이너에서 키로 사용할 수 있는 hashCode
- 클래스의 각 필드를 선언 순서대로 표시하는 문자열 표현을 만들어주는 toString

추가로 JPA Entity(Spring) 에서 data class 사용을 권장하지 않는다.
- data class를 Entity 클래스로 사용할 경우 equals(), hashCode(), toString() 는 필수로 오버라이딩 해줘야 한다.
  일반 class 를 Entity로 사용할 때도 마찬가지이긴 한데 JPA를 사용하다보면 양방향 연관관계를 맺는 경우도 생기는데 이때 별 생각없이 위 메서드들을 구현해서 사용하면 순환참조 오류(toString 무한)가 발생할 수 있다.
  이처럼 어차피 equals(), hashCode(), toString() 를 오버라이딩 해야 한다면 굳이 data class 사용할 필요가 없다.
- data class 불변클래스로 사용하는 것이 권장되는데 이 경우 JPA 의 dirty checking 기능을 사용할 수 없다. 물론 data class 를 가변클래스로 사용할 수도 있겠지만 가변클래스로 사용할 거라면 굳이 불변클래스로 사용하는 것이 권장되는 data class 를 사용할 필요가 없다.
- JPA 의 lazy loading 은 상속을 이용해서 proxy 객체를 만들게 되는데 상속이 막혀있어 의도와 달리 eager loading 으로 동작하게 된다.
  물론 allopen 이라는 gradle 플러그인을 사용하면 컴파일 과정에서 open 이 강제로 추가되어 상속에 사용될 순 있지만 data class 에 open 를 지원하지 않는 것이 코틀린 언어스펙인데 굳이 이를 무시하게 된다.


## 데이터 클래스와 불변성 : copy() 메서드

copy()는 *방어적 복사가 되는가?
* 방어적 복사 : 생성자를 통해 초기화하거나 내부의 객체를 반환할 때, 새로운 객체로 감싸서 복사해주는 방법이다. 외부와 내부에서 주소 값을 공유하는 인스턴스의 관계를 끊어주기 위함이다.

ChatGPT 답변
data class의 copy() 메서드는 방어적 복사(Defensive Copy)를 수행하지 않습니다. 방어적 복사란, 객체를 복사할 때 원본 객체의 내부 상태를 변경하지 않도록 하는 것을 말합니다.
따라서, Kotlin의 data class의 copy() 메서드는 복사된 객체를 변경하면 원본 객체도 함께 변경될 수 있습니다. 만약 방어적 복사가 필요한 경우에는 개발자가 직접 방어적 복사를 수행해야 합니다.

그렇다면 코틀린에서 방어적 복사는 어떻게 해야 하는가?
방어적 복사를 수행하려면, 'copy()' 메서드를 사용하여 객체를 복사한 후, 내부 객체까지 모두 복사하여 새로운 객체를 생성해야 한다. 이를 깊은 복사(Deep Copy)라고 한다 .

```kotlin
data class Person(val name: String, val age: Int, val address: Address) {
    constructor(person: Person) : this(person.name, person.age, Address(person.address))
}
data class Address(val city: String, val street: String) {
    constructor(address: Address) : this(address.city, address.street)
}
```

## 클래스 위임 : by 키워드 사용

Kotlin에서 ' by' 키워드는 델리게이트(Delegate) 패턴을 구현할 때 사용됩니다. 델리게이트 패턴은 객체의 일부 기능을 다른 객체에게 위임하는 패턴입니다.
by 키워드는 클래스나 인터페이스를 상속받거나 구현할 때, _ 해당 클래스나 인터페이스의 일부 메서드를 다른 객체에게  위임하는 것을 간편하게 구현할 수 있도록 지원합니다.
예를 들어, 다음과 같은 인터페이스가 있다고 가정해봅시다.
```kotlin
interface MyInterface {
  fun doSomething()
}
```
이 인터페이스를 구현하는 클래스를 만들 때 'by' 키워드를 사용하면, 인터페이스의 메서드를 다른 객체에게 위임할 수 있습니다.
```kotlin
class MyClass(delegate: MyInterface) : MyInterface by delegate {
  // ...
}
```
위 코드에서 'MyClass'는 'MyInterface'를 구현하면서, delegate 객체에게 'MyInterface'의 메서드를 위임하도록 설정됩니다. 이렇게 하면 'MyClass' 의 객체가 MyInterface'의 메서드를 호출하면, delegate 객체의 메서드가 호출되어 실행됩니다.
이를 통해 코드 중복을 줄이고, 객체 간의 의존성을 낮출 수 있습니다. 또한, 런타임에 객체의 동작을 바꿀 수 있도록 유연성을 높일 수 있습니다.

## object 키워드 : 클래스 선언과 인스턴스 생성

 논의 내용
1. 다양한 구성 요소와 상호작용하는 대규모 컴포넌트에는 싱글턴이 적합하지 않다. 즉 싱글턴이 안티패턴인데 사용하는 이유가 있는가?
 -> 스프링에서는 많은 객체를 생성하고 관리하는 대신
   싱글톤으로 객체를 관리함으로써 메모리 사용량과 성능 개선을 위해 싱글톤 패턴을 사용합니다. 하지만 싱글톤 패턴에는 안티패턴으로 여겨지는 면이 있습니다.
   싱글톤 패턴은 객체를 한 번만 생성하여 필요한 모든 곳에서 사용하도록 하는 디자인 패턴입니다. 하지만 이로 인해 객체의 의존성이 높아져 유연성이 떨어질 수 있습니다. 또한 멀티스레드 환경에서 안전하지 않을 수 있습니다.
   스프링에서는 이러한 문제점을 보완하기 위해 싱글톤 객체가 멀티스레드 환경에서 안전하게 동작하도록 설계되어 있습니다.
   또한 스프링에서는 스프링 빈의 스코프(scope)를 설정하여 객체의 생명주기와 범위를 제어할 수 있습니다. 이를 통해 싱글톤 패턴의 문제점을 보완하면서도 객체의 생성 및 관리를 스프링이 담당할 수 있습니다.
   따라서 스프링에서 싱글톤 패턴을 사용하는 것은 안티패턴이 아니며, 스프링의 다양한 기능을 활용하여 객체의 범위와 생명주기를 유연하게 제어할 수 있습니다.

2. 동반 객체를 쓰는 이유
->
- 동반 객체는 클래스와 밀접하게 관련된 유틸리티 메서드를 제공하는 데 사용될 수 있습니다. 클래스의 인스턴스와 관련된 유틸리티 메서드를 제공할 때, 동반 객체를 사용하면 클래스 이름으로 바로 접근할 수 있어 편리합니다.
- 동반 객체는 클래스의 인스턴스를 생성하는 팩토리 메서드를 제공하는 데 사용될 수 있습니다. 이는 클래스 생성자에 대한 제한을 두는 등의 제약을 두고 싶을 때 유용합니다.
- 동반 객체는 인터페이스나 추상 클래스의 구현을 제공하는 데 사용될 수 있습니다. 인터페이스나 추상 클래스의 구현을 제공하는 경우, 인터페이스나 추상 클래스의 이름으로 바로 접근할 수 있어 편리합니다.
- 동반 객체는 클래스 내부에서 private 멤버에 대한 접근 권한을 부여하는 데 사용될 수 있습니다. 동반 객체의 멤버는 클래스의 멤버로 간주되므로, private 멤버에 접근할 수 있습니다.

3. 동반 객체에 이름이 없다면?

```kotlin
class Person(val name : String){
    companion object {
        fun fromJSON(jsonText : String) : Person = TODO()
    }
}

person = Person.Companion.fromJSON("test") // 요것도 가능
person = Person.fromJSON("test") // 요것도 가능
```
위와 같이 사용이 가능하다.