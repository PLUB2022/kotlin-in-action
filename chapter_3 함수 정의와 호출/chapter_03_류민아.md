## Ch_03. 함수 정의와 호출

## 🔴 빨강
- p.112 util 등 코틀린에서는 이런 무의미한 클래스가 필요 없음. 대신 함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 됨
- p.115 기존 코드와 코틀린 코드를 자연스럽게 통합하는 것은 코틀린의 핵심 목표 중 하나.
- p.115 확장 함수(estension fuction) : 어떤 클래스이 멤버 메서드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수
    
    → 기존 자바 API를 재작성하지 않고도 코틀린이 제공하는 여러 편리한 기능을 사용할 수 있게 해줌
    
    → 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이면 됨
    
    - 클래스의 이름 : 수신 객체 타입(receiver type)
    - 확장 함수가 호출의 대상이 되는 값 : 수신 객체 (receiver object)
- p.116 확장 함수가 캡슐화를 깨지는 않음!
- p.135 코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있음

## **🔵 파랑**
- p.105 코틀린은 자신만의 컬렉션 기능 제공 x. 기존 자바 컬렉션을 활용할 수 있음.
- p.105 표준 자바 컬렉션을 활용하면 자바 코드와 상호작용하기가 훨씬 더 쉬움
- p.105 코틀린 컬렉션은 자바 컬렉션과 똑같은 클래스. 하지만 코틀린에서 자바보다 더 많은 기능을 쓸 수 있음
- p.108 코틀린으로 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부,전부의 이름을 명시할 수 있음. 호출 시 인자 중 어느 하나라도 이름을 명시하면 혼동을 막기 위해 그 뒤에 오는 모든 인자는 이름 명시 필수
- p.109 이름 붙인 인자는 디폴트 파라미터 값과 함께 사용할 때, 쓸모 많음
- p.109 코틀린에서는 함수 선언에서 파라미터의 디폴트 값을 지정할 수 있으므로 불필요하게 중복되는 오버로드 중 상당수를 피할 수 있음
- p.110 함수의 디폴트 파라미터 값은 함수를 호출하는 쪽이 아니라 함수 선언 쪽에서 지정됨. 어떤 클래스 안에 정의된 함수의 디폴트 값을 바꾸고 그 클래스가 포함된 파일을 재컴파일하면 그 함수를 호출하는 코드 중에 값을 지정하지 않은 모든 인자는 자동으로 바뀐 디폴트 값을 적용받음
- p.110 @JVMOverloads 함수에 추가하면 코틀린 컴파일러가 자동으로 맨 마지막 파라미터로부터 파라미터를 하나씩 생략한 오버로딩한 자바 메서드를 추가
- p.116 확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 private, protected 멤버를 사용할 수 없음
- p.117 확장 함수를 사용하기 위해 그 함수를 다른 클래스나 함수와 마찬가지로 임포트해야함
    - 활용법 tip. Entity → DTO 변환을 service에 작성
- p.119 확장 함수는 단지 정적 메서드 호출에 대한 문법적인 편의일 뿐. 클래스가 아닌 더 구체적인 타입을 수신 객체 타입을 지정할 수 있음
- p.120 확장함수는 오버라이드 할 수 없음
- p.124 컬렉션 처리 중 코틀린 언어 특성
    - vararg 키워드 : 호출 시 인자 개수가 달라질 수 있는 함수를 정의
    - 중위 함수 호출 구문 : 인자가 하나뿐인 메서드를 간편하게 호출
    - 구조 분해 선언 : 복합적인 값을 분해해서 여러 변수에 나눠 담을 수 있음
- p.127 중위 호출(infix call) - 수신 객체와 유일한 메서드 인자 사이에 메서드 이름을 넣음
- p.127 구조 분해 선언(destructing declaration) … Pair 인스턴스 외 다른 객체. key, value 라는 두 변소를 맵의 원소를 사용해 초기화 가능
- p.129 코틀린 문자열은 자바 문자열과 같음
- p.131 코틀린에서는 정규식을 사용하지 않고도 문자열을 쉽게 파싱할 수 있음
- p.133 3중 따옴표 문자열을 문자열 이스케이프를 피하기 위해서만 사용하는 것은 아니고 줄 바꿈이 들어있는 프로그램 텍스트를 쉽게 문자열로 만들 수 있음
- p.134 라이브러리 알선(Pimp My Library) 패턴 : 기존 라이브러리를 새 언어에서 활용하는 패턴
- p.135 자바 코드를 작성할 때, DRY 원칙을 피하기 쉽지않음. 많은 경우 메서드 추출 리팩토링을 적용해 긴 메서드를 부분부분 나워서 각 부분을 재활용할 수 있음 → 클래스 안에 작은 메서드 많아지고, 메서드 간 관계를 파악하기 힘들어서 코드를 이해하기가 더 어려워질 가능성.
- p.137 로컬 함수는 자신이 속한 바깥 함수의 모든 파라미터와 변수 사용 가능
- p.138 코드를 확장 함수로 뽑아내는 기법은 놀랄 만큼 유용
- p.139 확장 함수를 로컬 함수로 정의할 수 있음 → 일반적으로는 한 단계만 함수를 중첩시키는 것을 권장

## **🟢 초록**
- p.107 제네릭 함수의 문법은 자바와 비슷
- p.107-8 이름 붙인 인자 : 인자로 전달한 것이 각 어떤 역할 하는지 구분이 쉬워 가독성 좋아짐
- p.116 클래스의 멤버 메서드와 확장 함수를 모두 메서드라 부름.
- p.117 as 키워드 → 임포트한 클래스나 함수를 다른 이름으로 부를 수 있음
    
    → 코틀린 문법상 확장함수는 반드시 짧은 이름 써야함 .. .어쩌구.저쩌구.이렇게 말고 .어쩌구 이렇게
    
- p.118 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메서드
- p.129 자바의 split의 구분 문자열은 실제로 정규식
- p.132 3중 따옴표 문자열에서는 역슬래시를 포함한 어떤 문자도 이스케이프할 필요 없음

### 요약
- 코틀린은 자체 컬렉션 클래스를 정의하지 않지만 자바 클래스를 확장해 더 풍부한 API 제공
- 함수 파라미터의 디폴트 값을 정의하면 오버로딩한 함수를 정의할 필요성 감소. 이름 붙인 인자 사용하면 함수의 인자가 많을 때, 함수 호출의 가독성을 더 향상시킬 수 있음
- 코틀린 파일에서 클래스 멤버가 아닌 최상위 함수와 프로퍼티를 직접 선언할 수 있음. 이를 활용하면 코드 구조를 더 유연하게 만들 수 있음
- 확장 함수, 프로퍼티를 사용해 외부 라이브러리에 정의된 클래스를 포함해 모든 클래스 API를 그 클래스의 소스코드를 바꿀 필요 없이 확장할 수 있음
- 중위 호출을 통해 인자가 하나 밖에 없는 메서드나 확장 함수를 더 깔끔한 구문으로 호출할 수 있음
- 코틀린은 정규식과 일반 문자열을 처리할 때 유용한 다양한 문자열 처리 함수를 제공
- 자바 문자열로 표현하려면 수많은 이스케이프가 필요한 문자열의 경우 3중 따옴표 문자열을 사용하면 더 깔끔하게 표현할 수 있음
- 로컬 함수를 써서 코드를 더 깔끔하게 유지하면서 중복을 제거할 수 있음